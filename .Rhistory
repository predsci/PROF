init_states['I_0'], init_states['S_0'], init_states['E_0'], init_states['R_0'],
mypar['rho'], round(mypar['baseline']), wl = wl)
# generate simulation data with the parameters defined above
model.pred <- simulate(seir2, format="data.frame", nsim = 1)
if (max(model.pred$cases) > mypar['baseline']){
icount = icount + 1
simdat[icount,] <- model.pred$cases
# create the time-series for beta(t)
beta_cur = as.numeric(mypar['Beta1'] + mypar['Beta2'])
beta_cur  = beta_cur +
as.numeric(mypar['Beta2'] - mypar['Beta1'])* tanh((1:ntimes_frcst-as.numeric(mypar['tcng1']))/wl)
beta_of_t[icount,] = beta_cur * 0.5 * gamma
}
if (icount == ntraj) break
}
simdat = simdat[1:icount,]
beta_of_t = beta_of_t[1:icount, ]
aaply(simdat,2,quantile,probs=c(0.025,0.25,0.5,0.75,0.975)) -> quantiles
aaply(beta_of_t,2,quantile,probs=c(0.025,0.25,0.5,0.75,0.975)) -> beta_quantiles
total=cbind(date = as.Date(dates_frcst, format = '%Y-%m-%d'),time.weeks = 1:ntimes_frcst,quantiles, reported = c(data[,'cases'], rep(NA, nfrcst)))
total = as.data.frame(total)
data_beta = cbind(date = as.Date(dates_frcst, format = '%Y-%m-%d'),time.weeks = 1:ntimes_frcst,beta_quantiles)
data_beta = as.data.frame(data_beta)
pl[[ireg]] <- ggplot(data=total,
mapping=aes(x=dates_frcst))+
geom_line(aes(y=`50%`),color='red')+
geom_ribbon(aes(ymin=`2.5%`,ymax=`97.5%`),fill='red',alpha=0.2)+
geom_ribbon(aes(ymin=`25%`,ymax=`75%`),fill='red',alpha=0.4)+
geom_point(aes(y=reported),color='black')+
labs(y="Daily New Hosp",x="Date") + ggtitle(reg_name)
pl[[ireg]]
ireg = which(regions == "LA")
reg_name = regions[ireg]
population = reg_pop[ireg]
my_inc = reg_hosp$conf_covid_admin[[ireg]]
# 7-day moving average
rolling_avg = zoo::rollmean(my_inc, k = 7, fill = NA, align = 'center')
my_inc = my_inc[keep_ind]
rolling_avg = round(rolling_avg[keep_ind])
# the last three data points are NA so replace them with the original values
na_ind <- which(is.na(rolling_avg))
rolling_avg[na_ind] <- my_inc[na_ind]
res_parametric_si <- estimate_R(rolling_avg[1:n_EpiEstim],
method= "uncertain_si",
config = config)
I0_est[ireg] <- res_parametric_si$I_imported[1]
I0_est[ireg] <- max(I0_est[ireg], I0_min)
cat(ireg, regions[ireg], I0_est[ireg],'\n')
data = data.frame(dates = dates, time = 1:ntimes, cases = my_inc, cases_roll = rolling_avg)
pop = round(population)
I_0 = I0_est[ireg]
E_0 = I_0
S_0 = pop - (E_0+ I_0)
R_0 = 0
# this is in days - will be converted to weeks below
# rates are 1/gamma and 1/mu_IH
gamma = 4.
# in days will be fitted
mu_H1H2 = 1.
# in days-1
cases_max = max(data[,'cases'])
if (cases_max <= 15 ) {
Beta = 1.05 / gamma
} else if(cases_max < 35 & cases_max > 15) {
Beta = 1.2/gamma #2/gamma
}  else {
Beta = 0.5 #2.5 / gamma
}
mu_EI = 1.0
# The range seems of pH seems to be 0.003414634 - 0.01731707
# we will optimize rho
pH = 0.01
rho = 0.95
# wl determines the time it takes beta to change value
# it is something like 2-3 times wl
wl = 3.0
# for now this is not optimized - we may want to change this
iorder=order(data$cases)
baseline = round(mean(data[iorder[1:14],'cases']))
# end_of_season = TRUE #FALSE #TRUE
# if (end_of_season) {
#   baseline = round(mean(data[c((ndates-7):ndates),'cases']))
# }
states <- c("S",'E','I','R','H1','H2','Ic','Ih')
nstates <- length(states)
init_states = c(S_0 = round(S_0), E_0 = round(E_0), I_0 = round(I_0), R_0 = round(R_0), H1_0 = 0, H2_0 = 0, Ic_0 = 0, Ih_0 = 0)
# order of parameters is important
# the number of values for beta and the time when they change relative to the previous one not absolute
nb = 2
# array of values and time change for Beta values
beta_vec = rep(Beta, nb)
beta_vec = runif(nb,Beta*0.95, Beta*1.05)
tcng_vec = rep(round(ntimes/(nb)), nb)
tcng_vec[nb] = 0.0
parnames = c('pop', 'gamma', 'pH', 'mu_H1H2', 'mu_EI', 'rho', 'baseline')
nparam = length(parnames)
nparamtot = nparam + nb * 2
betanames = paste0('Beta', 1:nb)
tcngnames = paste0('tcng', 1:nb)
# full list of parameter names including the time-dependent beta
parnames = c(parnames, betanames, tcngnames)
# Build the initial guess for all the parameters
par =rep(NA, nparamtot)
# change to pop, gamma, pH, mu_H1H2, mu_EI, rho, baseline
param_fort = c(pop = pop, gamma = 1./gamma, pH = pH, mu_H1H2 = 1/mu_H1H2, mu_EI= 1/mu_EI, rho = rho, baseline=baseline)
par[1:nparam] = param_fort
par[(nparam+1):(nparam+nb)] = beta_vec
par[(nparam+nb+1):(nparam+nb*2)] = tcng_vec
names(par) <- parnames
times = data[,'time']
ntimes  = length(times)
# tims-step
dt = 1./10.
t0 = 0
accum = c('Ic', 'Ih')
iaccum = which(states %in% accum)
naccum = length(accum)
obs = data[,'cases']
# Gamma function of observed cases
gamaObs = lgamma((round(obs) + 1))
wght = rep(1.0, ntimes)
nMCMC = 1e6
nlines = 1e4
ithin = round(nMCMC/nlines)
iseed = as.numeric(Sys.time())
paropt = c('mu_H1H2', 'mu_EI', 'pH', 'baseline', betanames, tcngnames[1:(nb-1)])
ind_opt = which(names(par) %in% paropt)
nopt = length(ind_opt)
parmin = parmax = par
# should really code this by parameter with reasonable values - not less than 1 day-1
# and not more than maybe 6-7 days -1
parmin[ind_opt] = par[ind_opt] * 0.5
parmax[ind_opt] = par[ind_opt] * 2.0
parmin['pH'] = 1e-3
parmax['pH'] = 0.01
parmin[c('mu_H1H2', 'mu_EI')] = c(0.5,0.5)
parmax[c('mu_H1H2', 'mu_EI')] = c(3,3)
parmin[betanames] = 0.95/gamma
parmax[betanames] = 3.0/gamma
# ensure parmax['tcng1'] does not exceed ndates - 7 days
parmax[tcngnames] =round(parmax[tcngnames] * (ndates-7)/sum(parmax[tcngnames]))
#parmin['tcng1'] = 213
# sanity check - ensure that initial guesses for Beta/time of change are within
# the allowed range
for(my_ind in ind_opt ) {
if (par[my_ind] >= parmax[my_ind] | par[my_ind] <= parmin[my_ind] ) {
par[my_ind] = parmin[my_ind] + 0.5*(parmax[my_ind] - parmin[my_ind])
}
print('initial guess for all parameters')
print(par)
step = rep(0.02, nparamtot)
traj = array(0, c(ntimes, nstates))
tab = array(0, c(nlines, (nparamtot + 1)))
cat("\nFitting Region: ", reg_name,'\n\n')
out <- .Fortran('mcmc', nstates = as.integer(nstates), init = as.double(init_states), param = as.double(par),
nparam = as.integer(nparam), nb = as.integer(nb), time = as.double(times), ntimes = as.integer(ntimes),
t0 = as.double(t0), dt = as.double(dt), traj = as.double(traj),
naccum = as.integer(naccum), iaccum = as.integer(iaccum),parmin = as.double(parmin),
parmax=as.double(parmax), step = as.double(step), wl = as.double(wl),
ind_opt = as.integer(ind_opt), nopt = as.integer(nopt),
obs = as.double(obs), gamaObs = as.double(gamaObs), wght = as.double(wght), nMCMC = as.integer(nMCMC),
ithin =as.integer(ithin), iseed = as.integer(iseed), tab = as.single(tab))
traj = array(out$traj, c(ntimes, nstates))
colnames(traj) <- states
traj = data.frame(traj)
param_best = out$param
names(param_best) <- parnames
traj[,'cases'] =rpois(ntimes, traj[,'Ih'] * param_best['rho'] + param_best['baseline'])
traj[,'obs'] = data[,'cases']
tab = array(out$tab, c(nlines, (nparamtot + 1)))
colnames(tab) <- c(parnames, 'llk')
##simulate
ntraj = 1000
z <- round(nlines/2):nlines
ind <- sample(z, round(1.2 * ntraj))
#iorder = order(tab[,'llk'])
#ind <- iorder
simdat <- beta_of_t <- array(0, c(ntraj, ntimes_frcst))
# Here using a time-dependent version
parnames_td_seirh = c("Beta1","Beta2", "tcng1","wl","gamma","mu_H1H2","mu_EI", "pop","pH","S_0","E_0",'I_0',"R_0", "rho","baseline")
pomp(data=data.frame(time= 1:ntimes_frcst),
times="time",t0=0,
rprocess=euler(step.fun = Csnippet(td.seir.step),delta.t=1/40.),
accumvars = c("Ic", "Ih"),
rinit=td.init.seir,
rmeasure=rmeas,
dmeasure=dmeas,
obsnames="cases",
statenames=c("S","E","I","R","H1","H2","Ic","Ih", 'time'),
paramnames=parnames_td_seirh) -> seir2
icount=0
for (ii in ind) {
mypar <- tab[ii, 1:nparamtot]
coef(seir2) <- c(mypar['Beta1'], mypar['Beta2'], mypar['tcng1'], mypar['gamma'],
mypar['mu_H1H2'], mypar['mu_EI'], mypar['pH'], mypar['pop'],
init_states['I_0'], init_states['S_0'], init_states['E_0'], init_states['R_0'],
mypar['rho'], round(mypar['baseline']), wl = wl)
# generate simulation data with the parameters defined above
model.pred <- simulate(seir2, format="data.frame", nsim = 1)
if (max(model.pred$cases) > mypar['baseline']){
icount = icount + 1
simdat[icount,] <- model.pred$cases
# create the time-series for beta(t)
beta_cur = as.numeric(mypar['Beta1'] + mypar['Beta2'])
beta_cur  = beta_cur +
as.numeric(mypar['Beta2'] - mypar['Beta1'])* tanh((1:ntimes_frcst-as.numeric(mypar['tcng1']))/wl)
beta_of_t[icount,] = beta_cur * 0.5 * gamma
}
if (icount == ntraj) break
}
simdat = simdat[1:icount,]
beta_of_t = beta_of_t[1:icount, ]
aaply(simdat,2,quantile,probs=c(0.025,0.25,0.5,0.75,0.975)) -> quantiles
aaply(beta_of_t,2,quantile,probs=c(0.025,0.25,0.5,0.75,0.975)) -> beta_quantiles
total=cbind(date = as.Date(dates_frcst, format = '%Y-%m-%d'),time.weeks = 1:ntimes_frcst,quantiles, reported = c(data[,'cases'], rep(NA, nfrcst)))
total = as.data.frame(total)
data_beta = cbind(date = as.Date(dates_frcst, format = '%Y-%m-%d'),time.weeks = 1:ntimes_frcst,beta_quantiles)
data_beta = as.data.frame(data_beta)
pl[[ireg]] <- ggplot(data=total,
mapping=aes(x=dates_frcst))+
geom_line(aes(y=`50%`),color='red')+
geom_ribbon(aes(ymin=`2.5%`,ymax=`97.5%`),fill='red',alpha=0.2)+
geom_ribbon(aes(ymin=`25%`,ymax=`75%`),fill='red',alpha=0.4)+
geom_point(aes(y=reported),color='black')+
labs(y="Daily New Hosp",x="Date") + ggtitle(reg_name)
pl[[ireg]]
for (ii in ind) {
mypar <- param_best #tab[ii, 1:nparamtot]
coef(seir2) <- c(mypar['Beta1'], mypar['Beta2'], mypar['tcng1'], mypar['gamma'],
mypar['mu_H1H2'], mypar['mu_EI'], mypar['pH'], mypar['pop'],
init_states['I_0'], init_states['S_0'], init_states['E_0'], init_states['R_0'],
mypar['rho'], round(mypar['baseline']), wl = wl)
# generate simulation data with the parameters defined above
model.pred <- simulate(seir2, format="data.frame", nsim = 1)
if (max(model.pred$cases) > mypar['baseline']){
icount = icount + 1
simdat[icount,] <- model.pred$cases
# create the time-series for beta(t)
beta_cur = as.numeric(mypar['Beta1'] + mypar['Beta2'])
beta_cur  = beta_cur +
as.numeric(mypar['Beta2'] - mypar['Beta1'])* tanh((1:ntimes_frcst-as.numeric(mypar['tcng1']))/wl)
beta_of_t[icount,] = beta_cur * 0.5 * gamma
}
if (icount == ntraj) break
}
param_best
names(tab)
head(tab)
ii
mypar=tab[ii, 1:nparamtot]
mypar <- param_best
mypar
c(mypar['Beta1'], mypar['Beta2'], mypar['tcng1'], mypar['gamma'],
mypar['mu_H1H2'], mypar['mu_EI'], mypar['pH'], mypar['pop'],
init_states['I_0'], init_states['S_0'], init_states['E_0'], init_states['R_0'],
mypar['rho'], round(mypar['baseline']), wl = wl)
is.list(param_best)
mypar
mypar1=tab[ii, 1:nparamtot]
mypar1
mypar=param_best
mypar
mypar <- param_best
coef(seir2) <- c(mypar['Beta1'], mypar['Beta2'], mypar['tcng1'], mypar['gamma'],
mypar['mu_H1H2'], mypar['mu_EI'], mypar['pH'], mypar['pop'],
init_states['I_0'], init_states['S_0'], init_states['E_0'], init_states['R_0'],
mypar['rho'], round(mypar['baseline']), wl = wl)
# generate simulation data with the parameters defined above
model.pred <- simulate(seir2, format="data.frame", nsim = 1)
model.pred
icount=0
for (ii in ind) {
mypar <- param_best #tab[ii, 1:nparamtot]
coef(seir2) <- c(mypar['Beta1'], mypar['Beta2'], mypar['tcng1'], mypar['gamma'],
mypar['mu_H1H2'], mypar['mu_EI'], mypar['pH'], mypar['pop'],
init_states['I_0'], init_states['S_0'], init_states['E_0'], init_states['R_0'],
mypar['rho'], round(mypar['baseline']), wl = wl)
# generate simulation data with the parameters defined above
model.pred <- simulate(seir2, format="data.frame", nsim = 1)
if (max(model.pred$cases) > mypar['baseline']){
icount = icount + 1
simdat[icount,] <- model.pred$cases
# create the time-series for beta(t)
beta_cur = as.numeric(mypar['Beta1'] + mypar['Beta2'])
beta_cur  = beta_cur +
as.numeric(mypar['Beta2'] - mypar['Beta1'])* tanh((1:ntimes_frcst-as.numeric(mypar['tcng1']))/wl)
beta_of_t[icount,] = beta_cur * 0.5 * gamma
}
if (icount == ntraj) break
}
simdat = simdat[1:icount,]
beta_of_t = beta_of_t[1:icount, ]
aaply(simdat,2,quantile,probs=c(0.025,0.25,0.5,0.75,0.975)) -> quantiles
aaply(beta_of_t,2,quantile,probs=c(0.025,0.25,0.5,0.75,0.975)) -> beta_quantiles
total=cbind(date = as.Date(dates_frcst, format = '%Y-%m-%d'),time.weeks = 1:ntimes_frcst,quantiles, reported = c(data[,'cases'], rep(NA, nfrcst)))
total = as.data.frame(total)
data_beta = cbind(date = as.Date(dates_frcst, format = '%Y-%m-%d'),time.weeks = 1:ntimes_frcst,beta_quantiles)
data_beta = as.data.frame(data_beta)
pl[[ireg]] <- ggplot(data=total,
mapping=aes(x=dates_frcst))+
geom_line(aes(y=`50%`),color='red')+
geom_ribbon(aes(ymin=`2.5%`,ymax=`97.5%`),fill='red',alpha=0.2)+
geom_ribbon(aes(ymin=`25%`,ymax=`75%`),fill='red',alpha=0.4)+
geom_point(aes(y=reported),color='black')+
labs(y="Daily New Hosp",x="Date") + ggtitle(reg_name)
pl[[ireg]]
icount=0
for (ii in ind) {
mypar <- param_best * runif(1, 0.95, 1.05)#tab[ii, 1:nparamtot]
coef(seir2) <- c(mypar['Beta1'], mypar['Beta2'], mypar['tcng1'], mypar['gamma'],
mypar['mu_H1H2'], mypar['mu_EI'], mypar['pH'], mypar['pop'],
init_states['I_0'], init_states['S_0'], init_states['E_0'], init_states['R_0'],
mypar['rho'], round(mypar['baseline']), wl = wl)
# generate simulation data with the parameters defined above
model.pred <- simulate(seir2, format="data.frame", nsim = 1)
if (max(model.pred$cases) > mypar['baseline']){
icount = icount + 1
simdat[icount,] <- model.pred$cases
# create the time-series for beta(t)
beta_cur = as.numeric(mypar['Beta1'] + mypar['Beta2'])
beta_cur  = beta_cur +
as.numeric(mypar['Beta2'] - mypar['Beta1'])* tanh((1:ntimes_frcst-as.numeric(mypar['tcng1']))/wl)
beta_of_t[icount,] = beta_cur * 0.5 * gamma
}
if (icount == ntraj) break
}
simdat = simdat[1:icount,]
beta_of_t = beta_of_t[1:icount, ]
aaply(simdat,2,quantile,probs=c(0.025,0.25,0.5,0.75,0.975)) -> quantiles
aaply(beta_of_t,2,quantile,probs=c(0.025,0.25,0.5,0.75,0.975)) -> beta_quantiles
total=cbind(date = as.Date(dates_frcst, format = '%Y-%m-%d'),time.weeks = 1:ntimes_frcst,quantiles, reported = c(data[,'cases'], rep(NA, nfrcst)))
total = as.data.frame(total)
data_beta = cbind(date = as.Date(dates_frcst, format = '%Y-%m-%d'),time.weeks = 1:ntimes_frcst,beta_quantiles)
data_beta = as.data.frame(data_beta)
pl[[ireg]] <- ggplot(data=total,
mapping=aes(x=dates_frcst))+
geom_line(aes(y=`50%`),color='red')+
geom_ribbon(aes(ymin=`2.5%`,ymax=`97.5%`),fill='red',alpha=0.2)+
geom_ribbon(aes(ymin=`25%`,ymax=`75%`),fill='red',alpha=0.4)+
geom_point(aes(y=reported),color='black')+
labs(y="Daily New Hosp",x="Date") + ggtitle(reg_name)
pl[[ireg]]
head(tab)
dim(tab)
iorder = order(tab[,'llk'])
head(tab[iorder,])
icount=0
iorder = order(tab[,'llk'])
#for (ii in ind) {
for (ii in iorder) {
mypar <- tab[ii, 1:nparamtot] # param_best #tab[ii, 1:nparamtot]
coef(seir2) <- c(mypar['Beta1'], mypar['Beta2'], mypar['tcng1'], mypar['gamma'],
mypar['mu_H1H2'], mypar['mu_EI'], mypar['pH'], mypar['pop'],
init_states['I_0'], init_states['S_0'], init_states['E_0'], init_states['R_0'],
mypar['rho'], round(mypar['baseline']), wl = wl)
# generate simulation data with the parameters defined above
model.pred <- simulate(seir2, format="data.frame", nsim = 1)
if (max(model.pred$cases) > mypar['baseline']){
icount = icount + 1
simdat[icount,] <- model.pred$cases
# create the time-series for beta(t)
beta_cur = as.numeric(mypar['Beta1'] + mypar['Beta2'])
beta_cur  = beta_cur +
as.numeric(mypar['Beta2'] - mypar['Beta1'])* tanh((1:ntimes_frcst-as.numeric(mypar['tcng1']))/wl)
beta_of_t[icount,] = beta_cur * 0.5 * gamma
}
if (icount == ntraj) break
}
simdat = simdat[1:icount,]
beta_of_t = beta_of_t[1:icount, ]
aaply(simdat,2,quantile,probs=c(0.025,0.25,0.5,0.75,0.975)) -> quantiles
aaply(beta_of_t,2,quantile,probs=c(0.025,0.25,0.5,0.75,0.975)) -> beta_quantiles
total=cbind(date = as.Date(dates_frcst, format = '%Y-%m-%d'),time.weeks = 1:ntimes_frcst,quantiles, reported = c(data[,'cases'], rep(NA, nfrcst)))
total = as.data.frame(total)
data_beta = cbind(date = as.Date(dates_frcst, format = '%Y-%m-%d'),time.weeks = 1:ntimes_frcst,beta_quantiles)
data_beta = as.data.frame(data_beta)
pl[[ireg]] <- ggplot(data=total,
mapping=aes(x=dates_frcst))+
geom_line(aes(y=`50%`),color='red')+
geom_ribbon(aes(ymin=`2.5%`,ymax=`97.5%`),fill='red',alpha=0.2)+
geom_ribbon(aes(ymin=`25%`,ymax=`75%`),fill='red',alpha=0.4)+
geom_point(aes(y=reported),color='black')+
labs(y="Daily New Hosp",x="Date") + ggtitle(reg_name)
pl[[ireg]]
quit()
library(PROF)
quit()
library(PROF)
getwd()
# set path to location of example.R script
setwd("~/Dropbox/CSMB03/code/PROF/prof_dev")
# use the provided 'ex_hhs_data.R' script to download the HHS hospitlization
# file, subset to CA and format the data for both covid19 and influenza
source("ex_hhs_data.R")
plot_prof_data(prof_data = prof_data)
plot_prof_data(prof_data = prof_data)
# set path to location of example.R script
setwd("~/Dropbox/CSMB03/code/PROF/prof_dev")
# use the provided 'ex_hhs_data.R' script to download the HHS hospitlization
# file, subset to CA and format the data for both covid19 and influenza
source("ex_hhs_data.R")
plot_prof_data(prof_data = prof_data, filename=NULL)
plot_prof_data(prof_data = prof_data, filename=NULL)
plot_prof_data <- function(prof_data, filename = NULL) {
npath = length(prof_data)
if (npath > 1) par(mfrow = c(1,2))
for (ip in 1:npath) {
mydata = prof_data[[ip]]
reg_name = mydata$loc_name
disease = mydata$disease
inc = mydata$data$inc
dates  = mydata$data$date
inc_type = mydata$inc_type
cadence = as.numeric(dates[2]-dates[1])
if (cadence == 1) cadence_lab = 'Daily'
if (cadence == 7) cadence_lab = 'Weekly'
main_txt = paste0(reg_name, ' - ', disease,' ',cadence_lab)
start_year = lubridate::year(range(dates)[1])
end_year   = lubridate::year(range(dates)[2])
xlab = paste0(start_year,' - ', end_year)
plot(dates, inc, xlab = xlab, ylab = inc_type, main = main_txt)
cat(dates[1], dates[2], '\n')
}
if (is.null(filename)) {
# Display the plot on the screen
print(plot)
} else {
# Save the plot as a PDF file
pdf(filename)
print(plot)
dev.off()
}
return()
}
plot_prof_data(prof_data = prof_data)
plot_prof_data <- function(prof_data, filename = NULL) {
npath = length(prof_data)
#if (npath > 1) par(mfrow = c(1,2))
pl = list()
for (ip in 1:npath) {
mydata = prof_data[[ip]]
reg_name = mydata$loc_name
disease = mydata$disease
inc = mydata$data$inc
dates  = mydata$data$date
inc_type = mydata$inc_type
cadence = as.numeric(dates[2]-dates[1])
if (cadence == 1) cadence_lab = 'Daily'
if (cadence == 7) cadence_lab = 'Weekly'
main_txt = paste0(reg_name, ' - ', disease,' ',cadence_lab)
start_year = lubridate::year(range(dates)[1])
end_year   = lubridate::year(range(dates)[2])
xlab = paste0(start_year,' - ', end_year)
ylab = inc_type
data = data.frame(x=dates, y = inc)
pl[[ip]] <- ggplot(data, aes(x, y)) +
geom_point() +
labs(x = xlab,           # X-axis label
y = ylab,           # Y-axis label
title = main_txt)  # Main title
# plot(dates, inc, xlab = xlab, ylab = inc_type, main = main_txt)
#
# cat(dates[1], dates[2], '\n')
}
if (npath == 2) {
suppressWarnings(print(grid.arrange(pl[[1]], pl[[2]], ncol = 2)))
if (!is.null(filename)) {
suppressWarnings(print(grid.arrange(pl[[1]], pl[[2]], ncol = 2)))
ggsave(filename = filename, plot = grid_plots, width = 14, height = 6, dpi = 300)
cat("\n Saving Fit Plots to: ", filename,'\n')
}
} else {
suppressWarnings(pl[[1]])
if (!is.null(filename)) {
ggsave(filename = filename, plot = last_plot(), width = 7, height = 6, dpi = 300)
cat("\n Saving Fit Plots to: ", filename,'\n')
}
}
}
plot_prof_data(prof_data = prof_data)
library(ggplot2)
plot_prof_data(prof_data = prof_data)
library(PROF)
setwd("~/Dropbox/CSMB03/code/PROF/prof_dev")
# use the provided 'ex_hhs_data.R' script to download the HHS hospitlization
# file, subset to CA and format the data for both covid19 and influenza
source("ex_hhs_data.R")
# The 'prof_data' data structure should now be available and the data can
# be plotted
# To plot the data to a screen use:
plot_prof_data(prof_data = prof_data)
rm(list=ls())
rm(list=ls())
library(PROF)
setwd("~/Dropbox/CSMB03/code/PROF/prof_dev")
source("ex_hhs_data.R")
plot_prof_data(prof_data = prof_data)
library(devtools)
source('~/Dropbox/CSMB03/code/PROF/')
load_all('~/Dropbox/CSMB03/code/PROF/')
plot_prof_data(prof_data = prof_data)
load_all('~/Dropbox/CSMB03/code/PROF/')
plot_prof_data(prof_data = prof_data)
par_list = init_par_list(diseases=c("covid19", "influenza"),
models=c("seirh", "sirh"))
fit_list <- fit_data(prof_data = prof_data, par_list = par_list)
load_all('~/Dropbox/CSMB03/code/PROF/')
plot_fit(prof_data = prof_data, par_list = par_list, fit_list = fit_list)
load_all("~/Dropbox/CSMB03/code/PROF")
plot_forecast(prof_data = prof_data, par_list = par_list, fit_list = fit_list)
library(PROF)
quit()
