rm(list = ls())

library(usdata)
library(ggplot2)
library(grid)
library(gridExtra)
library(incidence)
library(scales)
library(pomp)
library(ggplot2)
library(plyr)
library(dplyr)
library(EpiEstim)

workdir=getwd()

source('util.R')

# Load the fortran codes
if (Sys.info()[5] == "arm64") {
  dyn.load("m1_src/detseirh.so")
  is.loaded("detseirh")

  dyn.load("m1_src/mcmc.so")
  is.loaded("mcmc")
} else {
  dyn.load("src/detseirh.so")
  is.loaded("detseirh")

  dyn.load("src/mcmc.so")
  is.loaded("mcmc")
}
data_path = "~/Dropbox/CSMB01/data/DICE_state_covid_hosp.rds"
funs_file_path = "~/Dropbox/CSMB01/data/code/hosp_data_funs.R"

#helper_path = "~/~/Dropbox/CSMB03/michal/code/v1-covid/helpers.R"

source(funs_file_path)
#source(helper_path)

# create a list for the results

all_state_hosp_frcst =list()

today = Sys.Date()

##########################################

# load the data
reg_hosp = readRDS(data_path)

# If you want to remove a location (American Samoa). However, all locations
# are accepted in the covid challenge.

reg_hosp = delete_locations(reg_hosp, locs=c("AS"))

dates = reg_hosp$dates

season_start = as.Date('2022-10-01', format = '%Y-%m-%d')

season_start = as.Date('2023-05-01', format = '%Y-%m-%d')

ind_start  = which(dates >= season_start)[1]

regions =reg_hosp$states$state

nfrcst = 50

nregion = length(regions)

reg_pop = reg_hosp$states$pop

keep_ind = which(dates >= season_start)

dates = dates[keep_ind]

ndates = length(dates)

ntimes = length(keep_ind)

ntimes_frcst= ntimes + nfrcst

# build also the arrays for the forecasts
dates_frcst = seq(from = dates[1], length = ntimes_frcst, by = '1 day')

I0_est = rep(0, nregion)

I0_min = 10

## we choose to draw:

config <- make_config(list(mean_si = 6.48, std_mean_si = 3.83, min_mean_si = 2.48, max_mean_si = 10.48, std_si = 10, std_std_si = 1, min_std_si = 1, max_std_si = 19))

n_EpiEstim = 35

pl = pl2 = pl_beta = list()
all_reg_frcst = list()

for (ireg in 1:nregion) {

reg_name = regions[ireg]

population = reg_pop[ireg]

my_inc = reg_hosp$conf_covid_admin[[ireg]]

# 7-day moving average
rolling_avg = zoo::rollmean(my_inc, k = 7, fill = NA, align = 'center')

my_inc = my_inc[keep_ind]

rolling_avg = round(rolling_avg[keep_ind])

# do not try to fit VI

if (reg_name == 'VI' | reg_name == 'WY') {
  data = data.frame(dates = dates, obs = my_inc)
  reg_hosp_frcst = list(reg = reg_name, data = data, profiles = list(dates = dates_frcst, profiles = NULL), fit = FALSE)
  all_reg_frcst[[ireg]] = reg_hosp_frcst
  cat("NOT FITTING ", reg_name, ' fit value ', reg_hosp_frcst$fit, '\n')

} else {


# the last three data points are NA so replace them with the original values
na_ind <- which(is.na(rolling_avg))
rolling_avg[na_ind] <- my_inc[na_ind]

res_parametric_si <- estimate_R(rolling_avg[1:n_EpiEstim],
                                method= "uncertain_si",
                                config = config)
I0_est[ireg] <- res_parametric_si$I_imported[1]
I0_est[ireg] <- max(I0_est[ireg], I0_min)

cat(ireg, regions[ireg], I0_est[ireg],'\n')

data = data.frame(dates = dates, time = 1:ntimes, cases = my_inc, cases_roll = rolling_avg)

pop = round(population)

I_0 = I0_est[ireg]

E_0 = I_0

S_0 = pop - (E_0+ I_0)

R_0 = 0

# this is in days - will be converted to weeks below
# rates are 1/gamma and 1/mu_IH

gamma = 4.

# in days will be fitted

mu_H1H2 = 1.

# in days-1

cases_max = max(data[,'cases'])
if (cases_max <= 15 ) {
  Beta = 1.05 / gamma
} else if(cases_max < 35 & cases_max > 15) {
  Beta = 1.2/gamma #2/gamma
}  else {
  Beta = 0.5 #2.5 / gamma
}

mu_EI = 1.0

# The range seems of pH seems to be 0.003414634 - 0.01731707
# we will optimize rho

pH = 0.01

rho = 0.95

# wl determines the time it takes beta to change value
# it is something like 2-3 times wl

wl = 3.0


# for now this is not optimized - we may want to change this
iorder=order(data$cases)
baseline = round(mean(data[iorder[1:14],'cases']))

# end_of_season = TRUE #FALSE #TRUE
# if (end_of_season) {
#   baseline = round(mean(data[c((ndates-7):ndates),'cases']))
# }


states <- c("S",'E','I','R','H1','H2','Ic','Ih')

nstates <- length(states)

init_states = c(S_0 = round(S_0), E_0 = round(E_0), I_0 = round(I_0), R_0 = round(R_0), H1_0 = 0, H2_0 = 0, Ic_0 = 0, Ih_0 = 0)

# order of parameters is important

# the number of values for beta and the time when they change relative to the previous one not absolute

nb = 2

# array of values and time change for Beta values
beta_vec = rep(Beta, nb)
beta_vec = runif(nb,Beta*0.95, Beta*1.05)
tcng_vec = rep(round(ntimes/(nb)), nb)
tcng_vec[nb] = 0.0


parnames = c('pop', 'gamma', 'pH', 'mu_H1H2', 'mu_EI', 'rho', 'baseline')

nparam = length(parnames)

nparamtot = nparam + nb * 2

betanames = paste0('Beta', 1:nb)
tcngnames = paste0('tcng', 1:nb)

# full list of parameter names including the time-dependent beta

parnames = c(parnames, betanames, tcngnames)

# Build the initial guess for all the parameters

par =rep(NA, nparamtot)

# change to pop, gamma, pH, mu_H1H2, mu_EI, rho, baseline

param_fort = c(pop = pop, gamma = 1./gamma, pH = pH, mu_H1H2 = 1/mu_H1H2, mu_EI= 1/mu_EI, rho = rho, baseline=baseline)

par[1:nparam] = param_fort

par[(nparam+1):(nparam+nb)] = beta_vec
par[(nparam+nb+1):(nparam+nb*2)] = tcng_vec

names(par) <- parnames

times = data[,'time']

ntimes  = length(times)

# tims-step

dt = 1./10.

t0 = 0

accum = c('Ic', 'Ih')
iaccum = which(states %in% accum)
naccum = length(accum)

obs = data[,'cases']
# Gamma function of observed cases

gamaObs = lgamma((round(obs) + 1))

wght = rep(1.0, ntimes)

nMCMC = 1e6
nlines = 1e4
ithin = round(nMCMC/nlines)

iseed = as.numeric(Sys.time())

paropt = c('mu_H1H2', 'mu_EI', 'pH', 'baseline', betanames, tcngnames[1:(nb-1)])

ind_opt = which(names(par) %in% paropt)

nopt = length(ind_opt)
parmin = parmax = par

# should really code this by parameter with reasonable values - not less than 1 day-1
# and not more than maybe 6-7 days -1

parmin[ind_opt] = par[ind_opt] * 0.5
parmax[ind_opt] = par[ind_opt] * 2.0

parmin['pH'] = 1e-3
parmax['pH'] = 0.01
parmin[c('mu_H1H2', 'mu_EI')] = c(0.5,0.5)
parmax[c('mu_H1H2', 'mu_EI')] = c(3,3)
parmin[betanames] = 0.95/gamma
parmax[betanames] = 3.0/gamma

# ensure parmax['tcng1'] does not exceed ndates - 7 days

parmax[tcngnames] =round(parmax[tcngnames] * (ndates-7)/sum(parmax[tcngnames]))



#parmin['tcng1'] = 213

# sanity check - ensure that initial guesses for Beta/time of change are within
# the allowed range

for(my_ind in ind_opt ) {
  if (par[my_ind] >= parmax[my_ind] | par[my_ind] <= parmin[my_ind] ) {
    par[my_ind] = parmin[my_ind] + 0.5*(parmax[my_ind] - parmin[my_ind])
  }
}

print('initial guess for all parameters')
print(par)

step = rep(0.02, nparamtot)

traj = array(0, c(ntimes, nstates))

tab = array(0, c(nlines, (nparamtot + 1)))

cat("\nFitting Region: ", reg_name,'\n\n')

out <- .Fortran('mcmc', nstates = as.integer(nstates), init = as.double(init_states), param = as.double(par),
                nparam = as.integer(nparam), nb = as.integer(nb), time = as.double(times), ntimes = as.integer(ntimes),
                t0 = as.double(t0), dt = as.double(dt), traj = as.double(traj),
                naccum = as.integer(naccum), iaccum = as.integer(iaccum),parmin = as.double(parmin),
                parmax=as.double(parmax), step = as.double(step), wl = as.double(wl),
                ind_opt = as.integer(ind_opt), nopt = as.integer(nopt),
                obs = as.double(obs), gamaObs = as.double(gamaObs), wght = as.double(wght), nMCMC = as.integer(nMCMC),
                ithin =as.integer(ithin), iseed = as.integer(iseed), tab = as.single(tab))

traj = array(out$traj, c(ntimes, nstates))

colnames(traj) <- states

traj = data.frame(traj)

param_best = out$param

names(param_best) <- parnames

traj[,'cases'] =rpois(ntimes, traj[,'Ih'] * param_best['rho'] + param_best['baseline'])

traj[,'obs'] = data[,'cases']

tab = array(out$tab, c(nlines, (nparamtot + 1)))

colnames(tab) <- c(parnames, 'llk')

##simulate

ntraj = 1000

z <- round(nlines/2):nlines
ind <- sample(z, round(1.2 * ntraj))

#iorder = order(tab[,'llk'])
#ind <- iorder
simdat <- beta_of_t <- array(0, c(ntraj, ntimes_frcst))

# Here using a time-dependent version
parnames_td_seirh = c("Beta1","Beta2", "tcng1","wl","gamma","mu_H1H2","mu_EI", "pop","pH","S_0","E_0",'I_0',"R_0", "rho","baseline")

pomp(data=data.frame(time= 1:ntimes_frcst),
     times="time",t0=0,
     rprocess=euler(step.fun = Csnippet(td.seir.step),delta.t=1/40.),
     accumvars = c("Ic", "Ih"),
     rinit=td.init.seir,
     rmeasure=rmeas,
     dmeasure=dmeas,
     obsnames="cases",
     statenames=c("S","E","I","R","H1","H2","Ic","Ih", 'time'),
     paramnames=parnames_td_seirh) -> seir2

icount=0

iorder = order(tab[,'llk'])

#for (ii in ind) {
  for (ii in iorder) {
  mypar <- tab[ii, 1:nparamtot] # param_best #tab[ii, 1:nparamtot]

  coef(seir2) <- c(mypar['Beta1'], mypar['Beta2'], mypar['tcng1'], mypar['gamma'],
                  mypar['mu_H1H2'], mypar['mu_EI'], mypar['pH'], mypar['pop'],
                  init_states['I_0'], init_states['S_0'], init_states['E_0'], init_states['R_0'],
                  mypar['rho'], round(mypar['baseline']), wl = wl)

  # generate simulation data with the parameters defined above

  model.pred <- simulate(seir2, format="data.frame", nsim = 1)
  if (max(model.pred$cases) > mypar['baseline']){
    icount = icount + 1
    simdat[icount,] <- model.pred$cases
    # create the time-series for beta(t)
    beta_cur = as.numeric(mypar['Beta1'] + mypar['Beta2'])
    beta_cur  = beta_cur +
      as.numeric(mypar['Beta2'] - mypar['Beta1'])* tanh((1:ntimes_frcst-as.numeric(mypar['tcng1']))/wl)
    beta_of_t[icount,] = beta_cur * 0.5 * gamma
  }

  if (icount == ntraj) break

}

simdat = simdat[1:icount,]
beta_of_t = beta_of_t[1:icount, ]

aaply(simdat,2,quantile,probs=c(0.025,0.25,0.5,0.75,0.975)) -> quantiles
aaply(beta_of_t,2,quantile,probs=c(0.025,0.25,0.5,0.75,0.975)) -> beta_quantiles

total=cbind(date = as.Date(dates_frcst, format = '%Y-%m-%d'),time.weeks = 1:ntimes_frcst,quantiles, reported = c(data[,'cases'], rep(NA, nfrcst)))

total = as.data.frame(total)

data_beta = cbind(date = as.Date(dates_frcst, format = '%Y-%m-%d'),time.weeks = 1:ntimes_frcst,beta_quantiles)
data_beta = as.data.frame(data_beta)

pl[[ireg]] <- ggplot(data=total,
       mapping=aes(x=dates_frcst))+
  geom_line(aes(y=`50%`),color='red')+
  geom_ribbon(aes(ymin=`2.5%`,ymax=`97.5%`),fill='red',alpha=0.2)+
  geom_ribbon(aes(ymin=`25%`,ymax=`75%`),fill='red',alpha=0.4)+
  geom_point(aes(y=reported),color='black')+
  labs(y="Daily New Hosp",x="Date") + ggtitle(reg_name)

# pl[[ireg]]

pl_beta[[ireg]] <- ggplot(data = data_beta, mapping=aes(x=dates_frcst)) +
  geom_line(aes(y=`50%`),color='red')+
  geom_ribbon(aes(ymin=`2.5%`,ymax=`97.5%`),fill='red',alpha=0.2)+
  geom_ribbon(aes(ymin=`25%`,ymax=`75%`),fill='red',alpha=0.4)+
  #geom_point(aes(y=reported),color='black')+
  labs(y="R(t)",x="Date") + ggtitle(reg_name) # + coord_cartesian(ylim=c(1,2.5))

# this is the format we want to save the data for the forecast also - we will be using 'dates_total

reg_hosp_frcst = list(reg = reg_name, data = data.frame(dates = dates, obs = my_inc), profiles = list(dates = dates_frcst, profiles = simdat), fit = TRUE)

all_reg_frcst[[ireg]] = reg_hosp_frcst

# update a temporary file with the figures
basename = paste0('inprogress_covid_state_frcst', Sys.Date())
ext = '.pdf'
filename = paste0(basename,ext)

ggsave(filename =filename, plot = marrangeGrob(pl, nrow=2, ncol=3), width = 15, height = 10)

# update a temorary RDS file
ext = '.rds'
filename = paste0(basename,ext)

saveRDS(all_reg_frcst, filename )
cat("\n\nSaving Data to: ", filename,'\n\n')

}

}

basename = paste0('state_covid_frcst', Sys.Date())

ext = '.rds'
filename = paste0(basename,ext)

saveRDS(all_reg_frcst, filename )
cat("\n\nSaving Data to: ", filename,'\n\n')

ext = '.pdf'
filename = paste0(basename,ext)

ggsave(filename =filename, plot = marrangeGrob(pl, nrow=2, ncol=3), width = 15, height = 10)

cat("\n\nSaving Plots to: ", filename,'\n\n')


# filename = paste0('~/Dropbox/CSMB03/CA2022-2023/influenza/Daily_profiles/',basename,ext)
# saveRDS(all_reg_frcst, filename )
# cat("\n\nSaving Data to: ", filename,'\n\n')


##



